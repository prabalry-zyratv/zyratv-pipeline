name: Build & Upload Videos

on:
  workflow_dispatch: {}
  push:
    paths:
      - "input/scripts/**"
      - "main.py"
      - "tts.py"
      - "video.py"
      - "requirements.txt"
      - ".github/workflows/pipeline.yml"

jobs:
  render:
    runs-on: ubuntu-latest
    env:
      # Rendering controls
      SEGMENTS: "3"                        # visuals per video (2â€“3 is good for 6â€“9 min)
      VIDEOS_LIMIT: ""                     # set to "1" to test a single video
      BURN_IN_CAPTIONS: "0"                # set to "1" later if you enable caption burn-in

      # Secrets (already added in repo Settings â†’ Secrets and variables â†’ Actions)
      PEXELS_API_KEY: ${{ secrets.PEXELS_API_KEY }}
      GOOGLE_DRIVE_FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}                 # OUTPUT folder
      GOOGLE_DRIVE_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}             # SA JSON
      GOOGLE_DRIVE_INPUT_FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_INPUT_FOLDER_ID }}     # INPUT folder

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install system deps (ffmpeg + fonts)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg fonts-dejavu-core

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # Drive libs for fetching + uploading
          pip install google-api-python-client google-auth google-auth-httplib2 google-auth-oauthlib

      - name: Fetch scripts from Google Drive â†’ input/scripts/**
        env:
          GDRIVE_JSON: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}
          INPUT_FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_INPUT_FOLDER_ID }}
        run: |
          python - << 'PY'
          import os, io, re, json, shutil, sys
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaIoBaseDownload

          # --- sanity: show which folder we're using
          input_root = os.environ.get('INPUT_FOLDER_ID', '').strip()
          if not input_root:
              print("âŒ GOOGLE_DRIVE_INPUT_FOLDER_ID is empty/missing.")
              sys.exit(1)
          print(f"ðŸ”Ž Using INPUT FOLDER ID: {input_root}")

          # --- auth
          try:
              creds_info = json.loads(os.environ['GDRIVE_JSON'])
          except Exception as e:
              print("âŒ Could not parse GOOGLE_DRIVE_CREDENTIALS JSON:", e)
              sys.exit(1)

          creds = service_account.Credentials.from_service_account_info(
              creds_info, scopes=['https://www.googleapis.com/auth/drive']
          )
          drive = build('drive', 'v3', credentials=creds)

          # clean local input/scripts to avoid stale files
          shutil.rmtree('input/scripts', ignore_errors=True)

          def list_children(folder_id, mime=None):
              q = f"'{folder_id}' in parents and trashed=false"
              if mime: q += f" and mimeType='{mime}'"
              items, token = [], None
              while True:
                  resp = drive.files().list(
                      q=q, fields="nextPageToken, files(id,name,mimeType)", pageToken=token
                  ).execute()
                  items.extend(resp.get('files', []))
                  token = resp.get('nextPageToken')
                  if not token: break
              return items

          def download_file(file, dest_path):
              os.makedirs(os.path.dirname(dest_path), exist_ok=True)
              mime = file.get('mimeType'); fid = file['id']
              buf = io.BytesIO()
              if mime == 'application/vnd.google-apps.document':
                  req = drive.files().export_media(fileId=fid, mimeType='text/plain')
              else:
                  req = drive.files().get_media(fileId=fid)
              downloader = MediaIoBaseDownload(buf, req)
              done = False
              while not done:
                  status, done = downloader.next_chunk()
              with open(dest_path, 'wb') as f:
                  f.write(buf.getvalue())
              print(f"â¬‡ï¸  Downloaded: {dest_path}")

          # Prefer subfolders (HM-HI, HT-EN, etc.)
          subs = list_children(input_root, mime="application/vnd.google-apps.folder")
          print("ðŸ“ Subfolders found:", [s['name'] for s in subs] or "(none)")

          downloaded = 0
          if subs:
              for sf in subs:
                  code = sf['name']  # e.g., HM-HI / HT-EN / MJ-BN
                  files = list_children(sf['id'])
                  if not files:
                      print(f"âš ï¸ Empty folder on Drive: {code}")
                  for f in files:
                      mt = f['mimeType']
                      if mt in ('text/plain','text/markdown','application/vnd.google-apps.document'):
                          base, _ = os.path.splitext(f['name'])
                          local = os.path.join('input','scripts',code, base + '.txt')
                          download_file(f, local)
                          downloaded += 1
                      else:
                          print(f"â­ï¸  Skipping non-text: {f['name']} ({mt})")
          else:
              # Files directly under root; derive channel_code from filename prefix "HM-HI-001.txt"
              files = list_children(input_root)
              print("ðŸ“„ Files in root:", [f['name'] for f in files])
              for f in files:
                  mt = f['mimeType']
                  if mt in ('text/plain','text/markdown','application/vnd.google-apps.document'):
                      base, _ = os.path.splitext(f['name'])
                      m = re.match(r'^([A-Z]{2}-[A-Z]{2})-', base)
                      code = m.group(1) if m else 'UNCATEGORIZED'
                      local = os.path.join('input','scripts',code, base + '.txt')
                      download_file(f, local)
                      downloaded += 1
                  else:
                      print(f"â­ï¸  Skipping non-text: {f['name']} ({mt})")

          print(f"âœ… Downloaded {downloaded} script file(s).")
          if downloaded == 0:
              print("âŒ No scripts downloaded. Fix one of these and rerun:")
              print("   â€¢ Confirm the Google Doc/Text exists in the INPUT folder.")
              print("   â€¢ The folder and subfolders are shared with the service account (Editor).")
              print("   â€¢ The secret GOOGLE_DRIVE_INPUT_FOLDER_ID matches the parent folder ID.")
              sys.exit(1)
          PY

      - name: Render videos
        run: |
          python -c "import sys,os; print('Python OK:', sys.version)"
          python main.py

            - name: Upload to Google Drive (Output folder)
        continue-on-error: true  # don't block artifacts if Drive upload fails
        env:
          GDRIVE_JSON: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}
          FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}
        run: |
          python - << 'PY'
          import os, json, glob
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload

          creds = service_account.Credentials.from_service_account_info(
              json.loads(os.environ['GDRIVE_JSON']),
              scopes=['https://www.googleapis.com/auth/drive']
          )
          drive = build('drive', 'v3', credentials=creds)

          files = glob.glob('output/final/*.mp4')
          if not files:
              print("No MP4s found in output/final â€” nothing to upload.")
              raise SystemExit(0)

          folder_id = os.environ['FOLDER_ID'].strip()

          for path in files:
              name = os.path.basename(path)
              meta  = {'name': name, 'parents': [folder_id]}
              media = MediaFileUpload(path, mimetype='video/mp4', resumable=False)
              created = drive.files().create(
                  body=meta,
                  media_body=media,
                  fields='id,name',
                  supportsAllDrives=True          # â† required for Shared drives
              ).execute()
              print(f"Uploaded {name} -> fileId {created.get('id')}")
          PY


      - name: Keep a copy as workflow artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: mp4-outputs
          path: output/final/*.mp4
          if-no-files-found: warn
